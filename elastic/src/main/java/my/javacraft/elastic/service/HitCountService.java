package my.javacraft.elastic.service;

import co.elastic.clients.elasticsearch.ElasticsearchClient;
import co.elastic.clients.elasticsearch._types.*;
import co.elastic.clients.elasticsearch.core.*;
import co.elastic.clients.elasticsearch.indices.DeleteIndexRequest;
import co.elastic.clients.elasticsearch.indices.DeleteIndexResponse;
import co.elastic.clients.json.JsonData;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.util.*;
import lombok.RequiredArgsConstructor;
import my.javacraft.elastic.model.HitCount;
import org.springframework.stereotype.Service;

/**
 * Index 'hit_count' should be created with the 'updated' field set up as a 'date' format. See README.md.
 */
@SuppressWarnings({"unchecked", "rawtypes"})
@Service
@RequiredArgsConstructor
public class HitCountService {

    static final String HIT_COUNT = "hit_count";

    private final ElasticsearchClient esClient;

    public String getCompositeId(HitCount hitCount) {
        // Elasticsearch autogenerated IDs uses a form of base64 encoding, see TimeBasedUUIDGenerator (repo: elastic/elasticsearch)
        // _id is limited to 512 bytes in size and larger values will be rejected, that means we should limit how we generated id.
        // UUID.nameUUIDFromBytes uses 3rd UUID type (Name-based)
        return UUID.nameUUIDFromBytes("%s_%s_%s_%s".formatted(
                hitCount.getUserId(),
                hitCount.getDocumentId(),
                hitCount.getSearchType(),
                hitCount.getSearchPattern()
        ).getBytes(StandardCharsets.UTF_8)).toString();
    }

    public UpdateResponse capture(HitCount hitCount) throws IOException {
        // default scripting language in Elasticsearch is 'painless'
        // It supports java8 syntax, but doesn't support the current datetime.
        InlineScript inlineScript = new InlineScript.Builder()
                .source("""
                                ctx._source.count++;
                                ctx._source.updated=params['updated'];
                        """)
                .params("updated", JsonData.of(getCurrentDate()))
                .build();
        Script script = new Script.Builder()
                .inline(inlineScript)
                .build();

        UpdateRequest updateRequest = new UpdateRequest.Builder<>()
                .index(HIT_COUNT)
                .id(getCompositeId(hitCount))
                .upsert(createInitialValues(hitCount))
                .script(script)
                .build();
        return esClient.update(updateRequest, Map.class);
    }

    public GetResponse<Map> getHitCount(String documentId) throws IOException {
        GetRequest getRequest = new GetRequest.Builder()
                .index(HIT_COUNT)
                .id(documentId)
                .build();

        return esClient.get(getRequest, Map.class);
    }

    public List<Map> searchHistoryByUserId(String userId) throws IOException {
        SearchRequest searchRequest = new SearchRequest.Builder()
                .index(HIT_COUNT)
                // search by userId
                .query(q -> q.term(t -> t
                        .field("userId")
                        .value(v -> v.stringValue(userId))
                ))
                .size(10) // limit result to 10 values
                // the result values with the highest count are going to be displayed
                .sort(so -> so.field(
                                FieldSort.of(f -> f
                                        .field("count")
                                        .order(SortOrder.Desc)
                                )
                        )
                ).build();

        return esClient.search(searchRequest, Map.class)
                .hits()
                .hits()
                .stream()
                .filter(hit -> hit.source() != null)
                .map(hit -> { // source doesn't contain document id
                    Map map = hit.source();
                    map.put("id", hit.id());
                    return map;
                })
                .toList();
    }

    public DeleteIndexResponse deleteIndex(String index) throws IOException {
        DeleteIndexRequest request = new DeleteIndexRequest.Builder()
                .index(index)
                .build();
        return esClient.indices().delete(request);
    }

    public DeleteResponse deleteDocument(String index, String documentId) throws IOException {
        DeleteRequest request = new DeleteRequest.Builder()
                .index(index)
                .id(documentId)
                .build();
        return esClient.delete(request);
    }

    Map<String, Object> createInitialValues(HitCount hitCount) {
        Map<String, Object> initialValues = new LinkedHashMap<>();
        initialValues.put("count", 1L);
        initialValues.put("updated", getCurrentDate());
        initialValues.put("userId", hitCount.getUserId());
        initialValues.put("documentId", hitCount.getDocumentId());
        initialValues.put("searchType", hitCount.getSearchType());
        initialValues.put("searchPattern", hitCount.getSearchPattern());
        return initialValues;
    }

    // returns: 2024-01-08T18:16:41.530571300Z
    private String getCurrentDate() {
        return DateTimeFormatter.ISO_INSTANT.format(Instant.now());
    }
}
